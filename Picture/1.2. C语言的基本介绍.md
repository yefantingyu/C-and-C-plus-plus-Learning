# CPU GPU 和寄存器基础知识

##### CPU： 高级计算器， 用于较快计算较简单的算术运算   ： 32*32

* ##### 算多位浮点型有些吃力，但其实也是可以算的

* ##### 现在的主板都集成显卡，目的就是计算高位数浮点数计算

##### GPU： 显卡  主要用于计算较多位浮点型的计算    32.112312312312412* 3123.1231232141241

## 总线

##### 在主板和零件之间传输信息，也就是传输 bit. 一条线路在同一时间仅能传输一个bit。

##### 总线可以同时传输的数据数为宽度： width， 单位为bit   总线宽度越大，性能越佳

##### 总线带宽：单位时间可以传输的总数据数       总线带宽 = 频率 * 宽度/8 （bytes/sec）

##### 总线我只需要知道三种：

* ##### 数据总线 Data Bus   在CPU与RAM之间来回传送需要处理或是需要储存的数据

* ##### 地址总线 Address Bus 用来指定在RAM（Random Access Memory）之中储存的数据的地址，用来沟通这些单元想要访问(读取/写入)计算机内存组件/地方的物理地址。

  

* ##### 控制总线（Control Bus）：将微处理器控制单元（Control Unit）的信号，传送到周边设备



##### 笔记本电脑其实是没有64位总线的，但其实是虚拟出来的64位总线。实际上是47位的总线

#####  

## 64 位系统和32位的区别

##### 系统多少位代表理论上最多能返回多少的系统总线

##### 32-bit CPU 默认为32-bit 地址总线，也相当于有32根数据传输线路

* ##### 最大可以表示 $2^{32}$ 中地址情况   $2^{32}=2^{10}(KB) \times 2^{10}(MB) \times  2^{10}(GB) \times 2^2$   相当于  4GB

* ##### 最大可以返回4GB的内存。也就相当于，装超过4GB的内存就失效了



##### 64-bit CPU 默认为64-bit地址总线，相当于有64根数据传输线路

* ##### 最大可以表示 $2^{64}$ 中地址情况   $2^{64}=2^{10}(KB) \times 2^{10}(MB) \times  2^{10}(GB) \times 2^{34}$   相当于  $2^{34}$GB

* ##### 64位的CPU是可以装32位系统的，也可以装64位系统。

* ##### 但其实我们不需要装这么大的内存，即使是服务器也是分布式的，不会把内存都汇集于一个点上



##### 64位系统的能运行32位的程序，但是32位的系统则不能运行64位的程序





## 寄存器

##### CPU 负责运算，寄存器则负责临时储存运算的数据，和返回的结果

##### 一般CPU的周围会集成一些寄存器

##### 缓存不是寄存器。缓存和内存差不多，只不过离CPU比较近，而且容量很小。访问缓存速度比内存要快的多，缓存的价格要贵的多

##### CPU 从缓存中取东西速度很快。一般来说，如果一个值频繁的使用，一般会放在寄存器和缓存中

<img src="C:\Users\DELL\Desktop\C_C++\图片\1.png" style="zoom:60%;" />

![](C:\Users\DELL\Desktop\C_C++\图片\2.png)

##### 程序一定实在在内存中执行。一些值要给CPU运算。然后CPU利用寄存器进行存储信息。运算完之后将结果返回给内存

##### 离CPU的远近程度 寄存器--缓存---内存







C语言嵌套汇编



启动程序，系统分配一块内存

int 占4个字节。定义后，三个变量在内存中分别占据4个字节空间









c = a+b









机器语言 (machine language) 010011101  

* 编写麻烦
* 看不懂

汇编语言   add std 15

* 稍微易懂
* 比较依赖寄存器: 不同的寄存器就有不同的汇编语言，遇到不同的寄存器就要重写编写程序：程序完全不可移植



C语言

* 高级语言
* 一个C语言程序编译成汇编语言，再翻译成机器语言才能执行





编译：计算机把高级语言翻译成机器语言的过程



速度上来讲，高级语言最慢，C是高级语言最快的，然后是汇编，然后是机器语言



C语言特点：

1. 代码量小
   * 其他的代码量小是因为他们是封装成的库，直接调库当然简单
   * 一些库基本上都是C语言写的，部分是C++
2. 执行速度快
3. 功能强大
4. 编程自由，无限制

缺点

1. 写代码实现周期长
2. 可移植性比较差，因为windows linux mac的C语言程序容易各有各的区别
3. 过于自由，容易出错
4. 对平台库依赖比较多



Unix, Linux, Java, C++， C# 底层都是靠C实现的









编译器：也是个应用程序

* gcc.exe： c 文件

* g++.exe 编译C++文件









# C语言编译步骤

<img src=".\图片\0\1. C语言编译步骤.png" style="zoom: 67%;" />

##### C代码编译成可执行程序经过4步：

##### 1. 预处理: .c 文件到 .i文件   .i文件为预处理文件

* ##### 宏定义展开
* ##### 头文件展开
* ##### 删除代码中的注释
* #####  ==不检查语法错误==:

  * ##### 不加结尾号, 代码写得不对,中文字符这些都能通过
##### 2. 编译: .i 文件到 .s文件   .s文件为汇编文件

* ##### 检查语法

* ##### 将预处理文件转化为汇编文件

##### 3. 汇编：将汇编文件生成目标文件(二进制文件)  .s文件到 .o文件   .o文件为二进制文件

* ##### 这一步产生的文件还是不能执行的, 因为缺少必要的链接库

##### 4. 链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去

* 设置启动代码和系统资源
* 设置堆栈空间
* 连接一些必要的系统执行库
* 



## gcc分步编译

##### 首先，之前的 -o 是一步到位的编译

* ##### 但其实, 编译器自动完成了预处理、编译、汇编、链接的过程

```C
gcc file.c -o file
./file.exe    
```

 ##### 但其实，我们可以分步骤编译

```C
预处理：gcc -E hello.c -o hello.i------hello.i是预处理文件
编  译：gcc -S hello.i -o hello.s------.s汇编文件
汇  编：gcc -c hello.s -o hello.o ----.o二进制文件
链  接：gcc    hello.o -o hello -------最后这个是可执行文件
```

| **选项** | **含义**                    |
| -------- | --------------------------- |
| -E       | 只进行预处理                |
| -S(大写) | 只进行预处理和编译          |
| -c(小写) | 只进行预处理、编译和汇编    |
| -o file  | 指定生成的输出文件名为 file |

| **文件后缀** | **含义**                          |
| ------------ | --------------------------------- |
| .c           | C 语言文件                        |
| .i           | 预处理后的 C 语言文件  预处理文件 |
| .s           | 编译后的汇编文件 汇编文件         |
| .o           | 编译后的目标文件  二进制文件      |

## 预处理
##### 预处理：```gcc -E hello.c -o hello.i```
##### hello.i 就是预处理文件.它和hello.c有一些相似的地方
##### C文件中凡是 \#开头的都是预处理指令,在预编译的时候就是处理带#的内容
##### 要预处理的东西一定前面有#

###　头文件展开

##### hello.c

```C
#include <stdio.h>

int main() {
	printf("Hellow world");
	return 1;

}
```

##### hello.i

```C
---
---
---
int main() {
	printf("Hellow world");
	return 1;
}
```

##### ```#include <stdio.h>```  就是预处理时把文件stdio.h中的内容全部拷贝进预处理文件中

##### 对于头文件来说, 这些文件或者内容在预处理的时候会被完整的拷贝到.i文件中

##### \#include 也可以拷贝.c文件

* ##### 它可以包含任意的文件，但是头文件我们一般定义为.h文件
  
  * ##### 头文件：对于函数声明

###  删除注释

//     /**/两种注释   预处理时候会把注释全部删掉

##### C语言中有两种注释 ```//``` 和 ```/**/```.  在预处理的时候,这些注释都会被完全删除掉


### 宏替换

##### \# define： 定义一个宏   宏就是等价: 一般来说相当于给一个值或者表达式赋一个名，前面的名字就是宏

* ##### 宏替换就是把所有代码中出现的宏, 在预处理的时候都替换为相应的表达式或者值

##### C文件

```C
#define PI 3.14     PI就是宏

int main()
{
    printf("123%lf",PI);
    return 0;
}    
```

##### .i文件

```C++
int main()
{
    printf("123%lf",3.14);
    return 0;
}    
```

### 条件编译

##### \#if 和 \#endif一般成对出现

##### #if 0 #endif 表示这个语句不会执行的,在预处理的时候也不会执行

##### #if 1 #endif 表示这个语句执行执行的,在预处理的时候会编译出来

##### C

```C
int main()
{
#if 0
	printf("123")
#endif
} 

int main()
{
#if 1
	printf("123");
#endif
} 
```

##### .i 文件

```C
int main()
{
} 

int main()
{
    printf("123");
} 
```

##### 如果预编译为空，说明这个条件不存在,也就是这个条件没被定义过,或者没值

```C
int main()
{
#if abc
	printf("123")
#endif
} 
```

##### 在编译的时候可以加上条件，-D条件,这样就可以让预编译出来了

```C
gcc -E hello.c -o hello.i -Dabc
```







* 